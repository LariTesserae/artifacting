/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Artifacting
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  screenshotInputFolder: "Inbox/Screenshots",
  screenshotNoteFolder: "Artifacts/Screenshots",
  mergedNotesArchivePath: "Artifacts/MergedNotesArchive",
  enableLoomBackup: true,
  loomBackupFolderPath: "ArtifactingData/LoomBackups",
  maxLoomBackups: 5,
  loomBackupGrowthThresholdKB: 512,
  enableDailyLoomBackupCheck: true,
  dailyLoomBackupCheckTime: "06:00",
  enableNewScreenshotTag: true,
  newScreenshotTagName: "new_artifact",
  loomExportsFolderPath: "Artifacts/LoomExports"
};
function getTextExtractorApi(app) {
  var _a, _b, _c;
  try {
    const textExtractorPlugin = (_b = (_a = app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["text-extractor"];
    if (textExtractorPlugin && typeof ((_c = textExtractorPlugin.api) == null ? void 0 : _c.extractText) === "function") {
      return textExtractorPlugin.api;
    }
  } catch (err) {
    console.error("Error accessing Text Extractor API:", err);
  }
  return void 0;
}
var MergeNotesModal = class extends import_obsidian.Modal {
  // Definite assignment assertion
  constructor(app, plugin) {
    super(app);
    this.filesToMerge = [];
    this.outputFolderParentPath = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Merge Notes" });
    const fileSelectionStatusDiv = contentEl.createDiv();
    this.renderSelectedFiles(fileSelectionStatusDiv);
    const searchInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Search notes to add..."
    });
    searchInput.style.width = "100%";
    searchInput.style.marginBottom = "10px";
    const searchResultsDiv = contentEl.createDiv({ cls: "artifacting-merge-search-results" });
    searchResultsDiv.style.maxHeight = "200px";
    searchResultsDiv.style.overflowY = "auto";
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    const renderSearchResults = (query = "") => {
      searchResultsDiv.empty();
      const lowerCaseQuery = query.toLowerCase();
      const filteredFiles = query ? allMarkdownFiles.filter((f) => f.path.toLowerCase().includes(lowerCaseQuery)) : allMarkdownFiles;
      const filesToShow = query || filteredFiles.length < 20 ? filteredFiles : filteredFiles.slice(0, 20);
      if (filesToShow.length === 0 && query) {
        searchResultsDiv.createEl("p", { text: "No files match your search." });
        return;
      }
      if (filesToShow.length === 0 && !query) {
        searchResultsDiv.createEl("p", { text: "No markdown files in vault?" });
        return;
      }
      const listEl = searchResultsDiv.createEl("ul", { cls: "artifacting-merge-file-list artifacting-scrollable-list" });
      filesToShow.forEach((file) => {
        const isSelected = this.filesToMerge.find((f) => f.path === file.path);
        const listItem = listEl.createEl("li", {
          text: file.path,
          cls: `is-clickable ${isSelected ? "is-selected-for-merge" : ""}`
        });
        if (isSelected) {
          listItem.style.fontWeight = "bold";
        }
        listItem.onClickEvent(() => {
          if (!this.filesToMerge.find((f) => f.path === file.path)) {
            this.filesToMerge.push(file);
            if (this.filesToMerge.length === 1 && file.parent) {
              this.outputFolderParentPath = file.parent.path;
            } else if (this.filesToMerge.length === 1) {
              this.outputFolderParentPath = "/";
            }
            this.renderSelectedFiles(fileSelectionStatusDiv);
            renderSearchResults(searchInput.value);
          }
        });
      });
      if (filteredFiles.length > filesToShow.length) {
        searchResultsDiv.createEl("p", { text: `... and ${filteredFiles.length - filesToShow.length} more. Refine search.` });
      }
    };
    searchInput.addEventListener("input", () => {
      renderSearchResults(searchInput.value);
    });
    renderSearchResults();
    contentEl.createEl("p", { text: "New merged note name:" });
    this.noteNameInput = contentEl.createEl("input", {
      type: "text",
      value: `Merged Artifact ${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-")}.md`
    });
    const archiveDiv = contentEl.createDiv({ cls: "artifacting-merge-archive-div" });
    this.archiveOriginalsCheckbox = archiveDiv.createEl("input", {
      type: "checkbox",
      attr: { id: "archive-originals-checkbox" }
    });
    this.archiveOriginalsCheckbox.style.marginRight = "5px";
    archiveDiv.createEl("label", {
      text: "Archive original notes after merging?",
      attr: { for: "archive-originals-checkbox" }
    });
    const mergeButton = contentEl.createEl("button", { text: "Merge Notes" });
    mergeButton.onClickEvent(async () => {
      if (this.filesToMerge.length < 2) {
        new import_obsidian.Notice("Please select at least two notes to merge.");
        return;
      }
      const newName = this.noteNameInput.value;
      if (!newName || !newName.endsWith(".md")) {
        new import_obsidian.Notice("Please enter a valid note name ending with .md");
        return;
      }
      const shouldArchive = this.archiveOriginalsCheckbox.checked;
      await this.plugin.mergeNotesImplementation(this.filesToMerge, newName, this.outputFolderParentPath, shouldArchive);
      this.close();
    });
  }
  renderSelectedFiles(containerEl) {
    containerEl.empty();
    containerEl.createEl("h4", { text: "Files to Merge (click to remove, order is top-to-bottom):" });
    if (this.filesToMerge.length === 0) {
      containerEl.createEl("p", { text: "No files selected yet." });
      return;
    }
    const ul = containerEl.createEl("ul");
    this.filesToMerge.forEach((file, index) => {
      const li = ul.createEl("li", { text: `${index + 1}. ${file.path}`, cls: "is-clickable" });
      li.onClickEvent(() => {
        this.filesToMerge.splice(index, 1);
        if (this.filesToMerge.length > 0 && this.filesToMerge[0].parent) {
          this.outputFolderParentPath = this.filesToMerge[0].parent.path;
        } else if (this.filesToMerge.length > 0) {
          this.outputFolderParentPath = "/";
        } else {
          this.outputFolderParentPath = "";
        }
        this.renderSelectedFiles(containerEl);
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LoomSearchModal = class extends import_obsidian.SuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder("Search loom node text...");
  }
  getSuggestions(query) {
    if (!query) {
      return Object.values(this.plugin.index).sort((a, b) => b.id > a.id ? -1 : 1).slice(0, 20);
    }
    return this.plugin.searchLoomIndex(query);
  }
  renderSuggestion(node, el) {
    const query = this.inputEl.value.toLowerCase();
    let textSnippet = node.text.substring(0, 100) + (node.text.length > 100 ? "..." : "");
    const textEl = el.createDiv();
    if (query && node.text) {
      const nodeTextLower = node.text.toLowerCase();
      const matchIndex = nodeTextLower.indexOf(query);
      const snippetRadius = 60;
      if (matchIndex !== -1) {
        const startIndex = Math.max(0, matchIndex - snippetRadius);
        const endIndex = Math.min(node.text.length, matchIndex + query.length + snippetRadius);
        let prefix = startIndex > 0 ? "..." : "";
        let suffix = endIndex < node.text.length ? "..." : "";
        const rawSnippet = node.text.substring(startIndex, endIndex);
        const matchInSnippetIndex = rawSnippet.toLowerCase().indexOf(query);
        if (matchInSnippetIndex !== -1) {
          const highlightedSnippet = rawSnippet.substring(0, matchInSnippetIndex) + `<mark>${rawSnippet.substring(matchInSnippetIndex, matchInSnippetIndex + query.length)}</mark>` + rawSnippet.substring(matchInSnippetIndex + query.length);
          textEl.innerHTML = prefix + highlightedSnippet + suffix;
        } else {
          textEl.setText(prefix + rawSnippet + suffix);
        }
      } else {
        textEl.setText(textSnippet);
      }
    } else {
      textEl.setText(textSnippet);
    }
    el.createEl("small", { text: node.documentPath, cls: "loom-search-result-path" });
  }
  async onChooseSuggestion(node, evt) {
    console.log("Chosen loom suggestion:", node);
    const activeFile = this.app.workspace.getActiveFile();
    const triggerSwitch = () => {
      console.log(`Triggering loom:switch-to for node ${node.id}`);
      this.app.workspace.trigger("loom:switch-to", node.id);
      new import_obsidian.Notice(`Attempting to switch loom to node: ${node.id.substring(0, 8)}...`);
    };
    if (activeFile && activeFile.path === node.documentPath) {
      triggerSwitch();
    } else {
      const targetFile = this.app.vault.getAbstractFileByPath(node.documentPath);
      if (targetFile instanceof import_obsidian.TFile) {
        console.log(`Opening file: ${node.documentPath}`);
        this.app.workspace.getLeaf(false).openFile(targetFile).then(() => {
          requestAnimationFrame(() => {
            requestAnimationFrame(triggerSwitch);
          });
        }).catch((err) => {
          console.error(`Error opening file ${node.documentPath}:`, err);
          new import_obsidian.Notice("Error opening loom document.");
        });
      } else {
        new import_obsidian.Notice(`Target file not found: ${node.documentPath}`);
      }
    }
  }
};
var ScreenshotSearchModal = class extends import_obsidian.SuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder("Search OCR text in images...");
  }
  getSuggestions(query) {
    if (!query) {
      return Object.values(this.plugin.screenshotIndex).filter((info) => !!info.lastOcrAttemptDate).sort((a, b) => (b.lastOcrAttemptDate || 0) - (a.lastOcrAttemptDate || 0)).slice(0, 20);
    }
    return this.plugin.searchScreenshots(query);
  }
  renderSuggestion(info, el) {
    let textSnippet = "(No OCR text available)";
    const currentQuery = this.inputEl.value.toLowerCase();
    if (info.ocrError) {
      textSnippet = `(OCR Error: ${info.ocrError.substring(0, 100)})`;
      el.createEl("div", { text: textSnippet });
    } else if (info.ocrText) {
      const ocrLower = info.ocrText.toLowerCase();
      const matchIndex = currentQuery ? ocrLower.indexOf(currentQuery) : -1;
      const snippetRadius = 60;
      if (currentQuery && matchIndex !== -1) {
        const startIndex = Math.max(0, matchIndex - snippetRadius);
        const endIndex = Math.min(info.ocrText.length, matchIndex + currentQuery.length + snippetRadius);
        let prefix = startIndex > 0 ? "..." : "";
        let suffix = endIndex < info.ocrText.length ? "..." : "";
        const rawSnippet = info.ocrText.substring(startIndex, endIndex);
        const matchInSnippetIndex = rawSnippet.toLowerCase().indexOf(currentQuery);
        if (matchInSnippetIndex !== -1) {
          const highlightedSnippet = rawSnippet.substring(0, matchInSnippetIndex) + `<mark>${rawSnippet.substring(matchInSnippetIndex, matchInSnippetIndex + currentQuery.length)}</mark>` + rawSnippet.substring(matchInSnippetIndex + currentQuery.length);
          el.createEl("div").innerHTML = prefix + highlightedSnippet + suffix;
        } else {
          el.createEl("div", { text: prefix + rawSnippet + suffix });
        }
      } else {
        textSnippet = info.ocrText.substring(0, 120) + (info.ocrText.length > 120 ? "..." : "");
        el.createEl("div", { text: textSnippet });
      }
    } else {
      el.createEl("div", { text: textSnippet });
    }
    el.createEl("small", { text: `Image: ${info.imagePath}`, cls: "artifacting-search-result-path" });
    if (info.notePath) {
      el.createEl("small", { text: ` | Note: ${info.notePath}`, cls: "artifacting-search-result-path" });
    }
  }
  async onChooseSuggestion(info, evt) {
    new import_obsidian.Notice(`Opening related to: ${info.imagePath}`);
    if (info.notePath) {
      const noteFile = this.app.vault.getAbstractFileByPath(info.notePath);
      if (noteFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf(false).openFile(noteFile);
      } else {
        console.warn(`Note path ${info.notePath} not found for image ${info.imagePath}, opening image directly.`);
        await this.app.workspace.openLinkText(info.imagePath, "", false);
      }
    } else {
      await this.app.workspace.openLinkText(info.imagePath, "", false);
    }
  }
};
var ArtifactingSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Artifacting Plugin Settings" });
    containerEl.createEl("h3", { text: "Screenshot Processing" });
    new import_obsidian.Setting(containerEl).setName("Screenshot Input Folder").setDesc("Folder to scan for new screenshots to process.").addText((text) => text.setPlaceholder("Example: Inbox/Screenshots").setValue(this.plugin.settings.screenshotInputFolder).onChange(async (value) => {
      this.plugin.settings.screenshotInputFolder = value;
      await this.plugin.savePluginSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Screenshot Notes Output Folder").setDesc("Folder where new notes for processed screenshots (from folder or clipboard) will be created.").addText((text) => text.setPlaceholder("Example: Artifacts/Screenshots").setValue(this.plugin.settings.screenshotNoteFolder).onChange(async (value) => {
      this.plugin.settings.screenshotNoteFolder = value;
      await this.plugin.savePluginSettings();
    }));
    new import_obsidian.Setting(containerEl).setName('Enable "New" Tag for Folder Screenshots').setDesc("If enabled, automatically adds a customizable tag to notes created from the input folder.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableNewScreenshotTag).onChange(async (value) => {
      this.plugin.settings.enableNewScreenshotTag = value;
      await this.plugin.savePluginSettings();
      this.display();
    }));
    if (this.plugin.settings.enableNewScreenshotTag) {
      new import_obsidian.Setting(containerEl).setName("Tag for New Folder Screenshots").setDesc('The tag to add (without #). E.g., "new_artifact" or "needs_review".').addText((text) => text.setPlaceholder("new_artifact").setValue(this.plugin.settings.newScreenshotTagName).onChange(async (value) => {
        const sanitizedTag = value.replace(/^#/, "").replace(/\s+/g, "_");
        this.plugin.settings.newScreenshotTagName = sanitizedTag;
        await this.plugin.savePluginSettings();
        text.setValue(sanitizedTag);
      }));
    }
    containerEl.createEl("h3", { text: "Note Merging" });
    new import_obsidian.Setting(containerEl).setName("Merged Notes Archive Folder").setDesc("Folder where original notes will be moved after merging (if 'archive' option is chosen).").addText((text) => text.setPlaceholder("Example: Artifacts/MergedNotesArchive").setValue(this.plugin.settings.mergedNotesArchivePath).onChange(async (value) => {
      this.plugin.settings.mergedNotesArchivePath = value;
      await this.plugin.savePluginSettings();
    }));
    containerEl.createEl("h3", { text: "Loomsidian Data Backup" });
    new import_obsidian.Setting(containerEl).setName("Enable Loomsidian Backup Feature").setDesc("If enabled, the plugin will manage backups for Loomsidian's data.json file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableLoomBackup).onChange(async (value) => {
      this.plugin.settings.enableLoomBackup = value;
      await this.plugin.savePluginSettings();
      this.display();
    }));
    if (this.plugin.settings.enableLoomBackup) {
      new import_obsidian.Setting(containerEl).setName("Loom Backup Folder Path").setDesc("Folder (relative to vault root) where Loomsidian data backups will be stored.").addText((text) => text.setPlaceholder("Example: ArtifactingData/LoomBackups").setValue(this.plugin.settings.loomBackupFolderPath).onChange(async (value) => {
        this.plugin.settings.loomBackupFolderPath = (0, import_obsidian.normalizePath)(value);
        await this.plugin.savePluginSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Maximum Loom Backups to Keep").setDesc("The number of recent Loomsidian backups to retain. Older backups will be deleted.").addText((text) => text.setValue(this.plugin.settings.maxLoomBackups.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 1) {
          this.plugin.settings.maxLoomBackups = num;
          await this.plugin.savePluginSettings();
        } else {
          new import_obsidian.Notice("Please enter a valid number (>= 1) for maximum backups.");
          text.setValue(this.plugin.settings.maxLoomBackups.toString());
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Backup Growth Threshold (KB)").setDesc("Create a backup if Loomsidian data grows by this many kilobytes since the last backup.").addText((text) => text.setValue(this.plugin.settings.loomBackupGrowthThresholdKB.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 1) {
          this.plugin.settings.loomBackupGrowthThresholdKB = num;
          await this.plugin.savePluginSettings();
        } else {
          new import_obsidian.Notice("Please enter a valid number (>= 1KB) for growth threshold.");
          text.setValue(this.plugin.settings.loomBackupGrowthThresholdKB.toString());
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Enable Daily Backup Check").setDesc("In addition to startup/growth checks, also check daily at the specified time.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDailyLoomBackupCheck).onChange(async (value) => {
        this.plugin.settings.enableDailyLoomBackupCheck = value;
        await this.plugin.savePluginSettings();
        this.plugin.rescheduleDailyLoomBackupCheck();
      }));
      new import_obsidian.Setting(containerEl).setName("Daily Backup Check Time (HH:MM)").setDesc("Time for the daily backup check (24-hour format, e.g., 06:00 for 6 AM).").addText((text) => text.setPlaceholder("HH:MM").setValue(this.plugin.settings.dailyLoomBackupCheckTime).onChange(async (value) => {
        if (/^([01]\d|2[0-3]):([0-5]\d)$/.test(value)) {
          this.plugin.settings.dailyLoomBackupCheckTime = value;
          await this.plugin.savePluginSettings();
          this.plugin.rescheduleDailyLoomBackupCheck();
        } else {
          new import_obsidian.Notice("Please enter a valid time in HH:MM format.");
          text.setValue(this.plugin.settings.dailyLoomBackupCheckTime);
        }
      }));
    }
    containerEl.createEl("h3", { text: "Loom Export Settings" });
    new import_obsidian.Setting(containerEl).setName("Loom Exports Folder Path").setDesc("Folder where exported Loomsidian segments (JSON and MD files) will be saved.").addText((text) => text.setPlaceholder("Example: Artifacts/LoomExports").setValue(this.plugin.settings.loomExportsFolderPath).onChange(async (value) => {
      this.plugin.settings.loomExportsFolderPath = (0, import_obsidian.normalizePath)(value);
      await this.plugin.savePluginSettings();
    }));
  }
};
var LOOM_DATA_PATH = ".obsidian/plugins/loom/data.json";
var Artifacting = class extends import_obsidian.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.index = {};
    this.screenshotIndex = {};
    this.processedScreenshotPaths = [];
    this.lastLoomDataBackupSize = 0;
    this.dailyLoomBackupIntervalId = null;
    this.settings = { ...DEFAULT_SETTINGS };
  }
  async onload() {
    console.log("Loading Artifacting plugin");
    await this.loadPluginSettingsAndData();
    this.addSettingTab(new ArtifactingSettingTab(this.app, this));
    this.addCommand({
      id: "index-looms",
      name: "Index Loom Data",
      callback: async () => {
        await this.buildLoomIndex(true);
      }
    });
    this.addCommand({
      id: "search-looms",
      name: "Search Looms",
      callback: () => {
        if (Object.keys(this.index).length === 0) {
          new import_obsidian.Notice('Loom Index is empty. Run "Index Loom Data" first.');
          return;
        }
        new LoomSearchModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "process-screenshots",
      name: "Process New Screenshots",
      callback: async () => {
        await this.processScreenshots(false);
      }
    });
    this.addCommand({
      id: "search-screenshots",
      name: "Search Screenshots (OCR Text)",
      callback: () => {
        if (Object.keys(this.screenshotIndex).length === 0) {
          new import_obsidian.Notice('Screenshot index is empty. Run "Scan/Update OCR for All Images" or process some screenshots first.');
          return;
        }
        new ScreenshotSearchModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "paste-image-from-clipboard",
      name: "Create Note from Clipboard Image",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "V" }],
      callback: async () => {
        await this.handlePasteFromClipboard();
      }
    });
    this.addCommand({
      id: "scan-all-images-ocr",
      name: "Scan/Update OCR for All Images in Vault",
      callback: async () => {
        await this.indexAllImagesOCR(true);
      }
    });
    this.addCommand({
      id: "create-note-for-active-file",
      name: "Create Note for Active File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile instanceof import_obsidian.TFile) {
          if (!checking) {
            this.handleCreateNoteForFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "merge-notes",
      name: "Merge Notes...",
      callback: () => {
        new MergeNotesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "manual-loom-backup",
      name: "Backup Loomsidian Data Now",
      callback: async () => {
        if (!this.settings.enableLoomBackup) {
          new import_obsidian.Notice("Loom backup feature is disabled in settings.");
          return;
        }
        await this.triggerLoomBackupCheck(true);
      }
    });
    this.addCommand({
      id: "export-active-document-loom",
      name: "Export active document's Loom to standalone artifact",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          if (!checking) {
            this.exportFullLoomForDocument(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, source) => {
        if (source === "file-explorer-context-menu") {
          if (file instanceof import_obsidian.TFile) {
            menu.addItem((item) => {
              item.setTitle("Artifacting: Create note for this file").setIcon("plus-circle").onClick(async () => {
                await this.handleCreateNoteForFile(file);
              });
            });
          }
        }
      })
    );
    await this.buildLoomIndex(false);
    this.app.workspace.onLayoutReady(async () => {
      console.log("Obsidian layout ready.");
      await new Promise((resolve) => setTimeout(resolve, 1500));
      console.log("Initial delay complete, proceeding with startup tasks for Artifacting.");
      await this.triggerLoomBackupCheck();
      await this.processScreenshots(false);
    });
    this.rescheduleDailyLoomBackupCheck();
  }
  async onunload() {
    console.log("Unloading Artifacting plugin");
    if (this.dailyLoomBackupIntervalId !== null) {
      window.clearInterval(this.dailyLoomBackupIntervalId);
      this.dailyLoomBackupIntervalId = null;
    }
    await this.savePluginData();
  }
  async loadPluginSettingsAndData() {
    var _a;
    const loadedData = await this.loadData();
    if (loadedData) {
      this.settings = {
        screenshotInputFolder: loadedData.screenshotInputFolder || DEFAULT_SETTINGS.screenshotInputFolder,
        screenshotNoteFolder: loadedData.screenshotNoteFolder || DEFAULT_SETTINGS.screenshotNoteFolder,
        mergedNotesArchivePath: loadedData.mergedNotesArchivePath || DEFAULT_SETTINGS.mergedNotesArchivePath,
        enableLoomBackup: typeof loadedData.enableLoomBackup === "boolean" ? loadedData.enableLoomBackup : DEFAULT_SETTINGS.enableLoomBackup,
        loomBackupFolderPath: loadedData.loomBackupFolderPath || DEFAULT_SETTINGS.loomBackupFolderPath,
        maxLoomBackups: typeof loadedData.maxLoomBackups === "number" ? loadedData.maxLoomBackups : DEFAULT_SETTINGS.maxLoomBackups,
        loomBackupGrowthThresholdKB: typeof loadedData.loomBackupGrowthThresholdKB === "number" ? loadedData.loomBackupGrowthThresholdKB : DEFAULT_SETTINGS.loomBackupGrowthThresholdKB,
        enableDailyLoomBackupCheck: typeof loadedData.enableDailyLoomBackupCheck === "boolean" ? loadedData.enableDailyLoomBackupCheck : DEFAULT_SETTINGS.enableDailyLoomBackupCheck,
        dailyLoomBackupCheckTime: loadedData.dailyLoomBackupCheckTime || DEFAULT_SETTINGS.dailyLoomBackupCheckTime,
        enableNewScreenshotTag: typeof loadedData.enableNewScreenshotTag === "boolean" ? loadedData.enableNewScreenshotTag : DEFAULT_SETTINGS.enableNewScreenshotTag,
        newScreenshotTagName: loadedData.newScreenshotTagName || DEFAULT_SETTINGS.newScreenshotTagName,
        loomExportsFolderPath: loadedData.loomExportsFolderPath || DEFAULT_SETTINGS.loomExportsFolderPath
      };
      this.index = loadedData.loomIndex || {};
      this.screenshotIndex = loadedData.screenshotIndex || {};
      this.processedScreenshotPaths = loadedData.processedScreenshotPaths || [];
      this.lastLoomDataBackupSize = typeof loadedData.lastLoomDataBackupSize === "number" ? loadedData.lastLoomDataBackupSize : 0;
    } else {
      this.settings = { ...DEFAULT_SETTINGS };
      this.index = {};
      this.screenshotIndex = {};
      this.processedScreenshotPaths = [];
      this.lastLoomDataBackupSize = 0;
    }
    console.log(`Loaded plugin data: ${Object.keys(this.index || {}).length} loom nodes, ${Object.keys(this.screenshotIndex || {}).length} screenshots indexed, ${((_a = this.processedScreenshotPaths) == null ? void 0 : _a.length) || 0} processed paths, lastLoomBackupSize: ${this.lastLoomDataBackupSize}`);
  }
  async savePluginData() {
    const dataToSave = {
      ...this.settings,
      loomIndex: this.index,
      screenshotIndex: this.screenshotIndex,
      processedScreenshotPaths: this.processedScreenshotPaths,
      lastLoomDataBackupSize: this.lastLoomDataBackupSize
    };
    await this.saveData(dataToSave);
    console.log("Saved plugin data.");
  }
  async savePluginSettings() {
    await this.savePluginData();
  }
  getTextExtractor() {
    return getTextExtractorApi(this.app);
  }
  async indexAllImagesOCR(isManualRun = false) {
    const textExtractor = this.getTextExtractor();
    if (!textExtractor) {
      new import_obsidian.Notice("Text Extractor plugin not found or not accessible. OCR scan aborted. Please install/enable it.", 0);
      console.warn("Text Extractor API not available for OCR scan.");
      return;
    }
    const initialMessage = "Starting vault-wide image OCR scan... This may take a while.";
    console.log(initialMessage);
    const progressNotice = isManualRun ? new import_obsidian.Notice(initialMessage, 0) : null;
    const allFiles = this.app.vault.getFiles();
    const imageFiles = allFiles.filter(
      (file) => ["png", "jpg", "jpeg", "gif", "bmp", "webp"].includes(file.extension.toLowerCase())
    );
    let newlyOcrCount = 0;
    const totalImages = imageFiles.length;
    for (let i = 0; i < totalImages; i++) {
      const imageFile = imageFiles[i];
      if (isManualRun) {
        const noticeMessage = `OCR Scan: Processing ${i + 1}/${totalImages} - ${imageFile.name}`;
        new import_obsidian.Notice(noticeMessage, 3e3);
      }
      console.log(`OCR Scan: Processing ${i + 1}/${totalImages} - ${imageFile.name}`);
      let existingEntry = this.screenshotIndex[imageFile.path];
      let shouldOcr = false;
      if (!existingEntry) {
        shouldOcr = true;
        existingEntry = {
          imagePath: imageFile.path,
          notePath: null,
          ocrText: null,
          ocrError: null,
          lastOcrAttemptDate: null,
          tags: []
        };
      } else {
        if (existingEntry.ocrText === null && existingEntry.ocrError === null) {
          shouldOcr = true;
        }
      }
      if (shouldOcr && textExtractor.canFileBeExtracted(imageFile.path)) {
        try {
          const ocrTextResult = await textExtractor.extractText(imageFile);
          console.log(`[RAW OCR - indexAllImagesOCR for ${imageFile.path}] Raw result type: ${typeof ocrTextResult}, Length: ${ocrTextResult == null ? void 0 : ocrTextResult.length}`);
          console.log(`[RAW OCR - indexAllImagesOCR for ${imageFile.path}] First 500 chars:`, ocrTextResult == null ? void 0 : ocrTextResult.substring(0, 500));
          existingEntry.ocrText = ocrTextResult && ocrTextResult.trim().length > 0 ? ocrTextResult.trim() : null;
          existingEntry.ocrError = null;
          newlyOcrCount++;
        } catch (err) {
          console.error(`  Text Extractor failed for ${imageFile.path}:`, err);
          existingEntry.ocrError = err.message || "Unknown OCR error during scan";
          existingEntry.ocrText = null;
        }
        existingEntry.lastOcrAttemptDate = Date.now();
      } else if (shouldOcr) {
        existingEntry.ocrError = "File type not processable by Text Extractor";
        existingEntry.lastOcrAttemptDate = Date.now();
        console.log(`  Skipping ${imageFile.path}, Text Extractor cannot process.`);
      }
      this.screenshotIndex[imageFile.path] = existingEntry;
      if (isManualRun && (i + 1) % 20 === 0 && i + 1 < totalImages) {
        new import_obsidian.Notice(`OCR Scan: Saved progress (${i + 1}/${totalImages})`, 2e3);
      }
    }
    await this.savePluginData();
    if (progressNotice)
      progressNotice.hide();
    const finalMessage = `Image OCR scan complete. ${newlyOcrCount} images OCR'd. ${totalImages} images checked/updated in index.`;
    console.log(finalMessage);
    if (isManualRun || newlyOcrCount < totalImages && totalImages > 0) {
      new import_obsidian.Notice(finalMessage, newlyOcrCount < totalImages && totalImages > 0 && !isManualRun ? 0 : 5e3);
    }
  }
  async createNoteAndIndexScreenshot(imageFile, outputFolderRelPath) {
    const initialOriginalPath = imageFile.path;
    let currentImagePath = imageFile.path;
    let movedFile = null;
    const attachmentLocationSetting = this.app.vault.getConfig("attachmentFolderPath");
    let targetAttachmentFolder = "";
    if (attachmentLocationSetting === "/") {
      targetAttachmentFolder = "/";
    } else if (attachmentLocationSetting.startsWith("./")) {
      console.warn("Attachment folder for clipboard images is set to be relative to current note. Defaulting to vault root for screenshot attachments for now.");
      targetAttachmentFolder = attachmentLocationSetting.substring(2);
    } else {
      targetAttachmentFolder = attachmentLocationSetting;
    }
    targetAttachmentFolder = (0, import_obsidian.normalizePath)(targetAttachmentFolder);
    if (targetAttachmentFolder !== "/" && !await this.app.vault.adapter.exists(targetAttachmentFolder)) {
      try {
        await this.app.vault.createFolder(targetAttachmentFolder);
      } catch (folderErr) {
        new import_obsidian.Notice(`Failed to create attachment folder: ${targetAttachmentFolder}. Screenshot will not be moved.`);
        console.error(`Failed to create attachment folder ${targetAttachmentFolder}:`, folderErr);
      }
    }
    if (targetAttachmentFolder === "/" || await this.app.vault.adapter.exists(targetAttachmentFolder)) {
      try {
        let desiredAttachmentPath = (0, import_obsidian.normalizePath)(`${targetAttachmentFolder}/${imageFile.name}`);
        let counter = 0;
        while (await this.app.vault.adapter.exists(desiredAttachmentPath)) {
          counter++;
          desiredAttachmentPath = (0, import_obsidian.normalizePath)(`${targetAttachmentFolder}/${imageFile.basename}-${counter}.${imageFile.extension}`);
        }
        console.log(`Moving ${initialOriginalPath} to ${desiredAttachmentPath}`);
        await this.app.vault.rename(imageFile, desiredAttachmentPath);
        currentImagePath = desiredAttachmentPath;
        const abstractMovedFile = this.app.vault.getAbstractFileByPath(currentImagePath);
        if (abstractMovedFile instanceof import_obsidian.TFile) {
          movedFile = abstractMovedFile;
        }
      } catch (err) {
        new import_obsidian.Notice(`Failed to move screenshot ${imageFile.name} to attachments folder. Note will link to original.`);
        console.error(`Failed to move screenshot ${initialOriginalPath} to attachments folder:`, err);
        currentImagePath = initialOriginalPath;
      }
    }
    const now = /* @__PURE__ */ new Date();
    const dateString = now.toISOString().split("T")[0];
    const noteName = `${imageFile.basename}_${dateString}.md`;
    const notePath = (0, import_obsidian.normalizePath)(`${outputFolderRelPath}/${noteName}`);
    let createdNote = null;
    const frontmatter = `---
artifactGeneratedDate: ${(/* @__PURE__ */ new Date()).toISOString()}
---`;
    const embedLink = `![[${currentImagePath}]]`;
    let noteContent = `${frontmatter}

${embedLink}

`;
    if (this.settings.enableNewScreenshotTag && this.settings.newScreenshotTagName) {
      noteContent += `#${this.settings.newScreenshotTagName}
`;
    }
    try {
      createdNote = await this.app.vault.create(notePath, noteContent);
      console.log(`Created note for screenshot: ${notePath}`);
    } catch (err) {
      new import_obsidian.Notice(`Failed to create note: ${notePath}`);
      console.error(`Failed to create note: ${notePath}`, err);
      return null;
    }
    const imagePathForIndex = movedFile ? movedFile.path : initialOriginalPath;
    this.screenshotIndex[imagePathForIndex] = {
      imagePath: imagePathForIndex,
      notePath,
      ocrText: null,
      ocrError: null,
      lastOcrAttemptDate: null,
      tags: this.settings.enableNewScreenshotTag && this.settings.newScreenshotTagName ? [this.settings.newScreenshotTagName] : []
    };
    return imagePathForIndex;
  }
  async processScreenshots(isManualRun = false) {
    if (isManualRun)
      new import_obsidian.Notice("Starting screenshot processing...");
    else
      console.log("Processing screenshots (startup)...");
    const inputFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.screenshotInputFolder);
    const inputFolder = this.app.vault.getAbstractFileByPath(inputFolderRelPath);
    if (!(inputFolder instanceof import_obsidian.TFolder)) {
      new import_obsidian.Notice(`Screenshot input folder not found: ${inputFolderRelPath}`);
      console.error(`Screenshot input folder not found: ${inputFolderRelPath}`);
      return;
    }
    const outputFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.screenshotNoteFolder);
    const outputFolder = this.app.vault.getAbstractFileByPath(outputFolderRelPath);
    if (!(outputFolder instanceof import_obsidian.TFolder)) {
      try {
        await this.app.vault.createFolder(outputFolderRelPath);
        console.log(`Created screenshot note folder: ${outputFolderRelPath}`);
      } catch (err) {
        new import_obsidian.Notice(`Failed to create screenshot note folder: ${outputFolderRelPath}`);
        console.error(`Failed to create screenshot note folder: ${outputFolderRelPath}`, err);
        return;
      }
    }
    let processedCount = 0;
    const filesToProcess = [...inputFolder.children];
    const imagesToOcrPaths = [];
    console.log(`Found ${filesToProcess.length} items in input folder ${inputFolderRelPath}`);
    for (const file of filesToProcess) {
      if (file instanceof import_obsidian.TFile && ["png", "jpg", "jpeg", "gif", "bmp", "webp"].includes(file.extension.toLowerCase())) {
        if (!this.processedScreenshotPaths.includes(file.path)) {
          console.log(`Processing new screenshot (note creation phase): ${file.path}`);
          const imagePathAfterProcessing = await this.createNoteAndIndexScreenshot(file, outputFolderRelPath);
          if (imagePathAfterProcessing) {
            imagesToOcrPaths.push(imagePathAfterProcessing);
            this.processedScreenshotPaths.push(file.path);
            processedCount++;
          }
        }
      }
    }
    if (processedCount > 0) {
      await this.savePluginData();
      new import_obsidian.Notice(`Processed ${processedCount} new screenshot(s). Notes created.`);
      console.log(`Created notes for ${processedCount} new screenshot(s).`);
      if (imagesToOcrPaths.length > 0) {
        this.batchOcrAndUpdateIndex(imagesToOcrPaths, isManualRun).then(() => {
          console.log("Background OCR processing finished for batch from input folder.");
        }).catch((err) => {
          console.error("Error during background batch OCR:", err);
          new import_obsidian.Notice("An error occurred during background OCR processing.");
        });
      }
    } else {
      new import_obsidian.Notice("No new screenshots found to process.");
      console.log("No new screenshots found.");
    }
  }
  async batchOcrAndUpdateIndex(imagePaths, isManualRun = false) {
    if (imagePaths.length === 0)
      return;
    const textExtractor = this.getTextExtractor();
    if (!textExtractor) {
      new import_obsidian.Notice("Text Extractor not available for background OCR. Please install/enable it.", 0);
      console.warn("Text Extractor API not available for background OCR batch.");
      for (const imagePath of imagePaths) {
        if (this.screenshotIndex[imagePath]) {
          this.screenshotIndex[imagePath].ocrError = "OCR not performed: Text Extractor plugin not found.";
          this.screenshotIndex[imagePath].lastOcrAttemptDate = Date.now();
        }
      }
      await this.savePluginData();
      return;
    }
    new import_obsidian.Notice(`Starting background OCR for ${imagePaths.length} image(s)...`, 5e3);
    console.log(`Starting background OCR for ${imagePaths.length} image(s)...`);
    let ocrSuccessCount = 0;
    for (let i = 0; i < imagePaths.length; i++) {
      const imagePath = imagePaths[i];
      const imageFile = this.app.vault.getAbstractFileByPath(imagePath);
      if (!imageFile) {
        console.warn(`Batch OCR: Image file not found at ${imagePath}, skipping.`);
        if (this.screenshotIndex[imagePath]) {
          this.screenshotIndex[imagePath].ocrError = "Image file not found during batch OCR.";
          this.screenshotIndex[imagePath].lastOcrAttemptDate = Date.now();
        }
        continue;
      }
      console.log(`Background OCR: ${i + 1}/${imagePaths.length} - ${imageFile.name}`);
      if (textExtractor.canFileBeExtracted(imageFile.path)) {
        try {
          const ocrTextResult = await textExtractor.extractText(imageFile);
          console.log(`[RAW OCR - batchOcrAndUpdateIndex for ${imagePath}] Raw result type: ${typeof ocrTextResult}, Length: ${ocrTextResult == null ? void 0 : ocrTextResult.length}`);
          console.log(`[RAW OCR - batchOcrAndUpdateIndex for ${imagePath}] First 500 chars:`, ocrTextResult == null ? void 0 : ocrTextResult.substring(0, 500));
          if (this.screenshotIndex[imagePath]) {
            this.screenshotIndex[imagePath].ocrText = ocrTextResult && ocrTextResult.trim().length > 0 ? ocrTextResult.trim() : null;
            this.screenshotIndex[imagePath].ocrError = null;
            ocrSuccessCount++;
          } else {
            console.warn(`Batch OCR: No existing index entry for ${imagePath} to update.`);
          }
        } catch (err) {
          console.error(`Batch OCR: Text Extractor failed for ${imagePath}:`, err);
          if (this.screenshotIndex[imagePath]) {
            this.screenshotIndex[imagePath].ocrError = err.message || "Unknown OCR error during batch scan";
            this.screenshotIndex[imagePath].ocrText = null;
          }
        }
      } else {
        console.log(`Batch OCR: Text Extractor cannot process ${imageFile.name}.`);
        if (this.screenshotIndex[imagePath]) {
          this.screenshotIndex[imagePath].ocrError = "File type not processable by Text Extractor.";
        }
      }
      if (this.screenshotIndex[imagePath]) {
        this.screenshotIndex[imagePath].lastOcrAttemptDate = Date.now();
      }
      if ((i + 1) % 5 === 0 && i + 1 < imagePaths.length) {
        await this.savePluginData();
        console.log(`Batch OCR: Saved intermediate progress to data.json`);
      }
    }
    await this.savePluginData();
    const finalMessage = `Background OCR finished. ${ocrSuccessCount}/${imagePaths.length} images successfully OCR'd.`;
    console.log(finalMessage);
    new import_obsidian.Notice(finalMessage, ocrSuccessCount === imagePaths.length ? 5e3 : 0);
  }
  async handlePasteFromClipboard() {
    try {
      const clipboardItems = await navigator.clipboard.read();
      let imageBlob = null;
      for (const item of clipboardItems) {
        const imageType = item.types.find((type) => type.startsWith("image/"));
        if (imageType) {
          imageBlob = await item.getType(imageType);
          break;
        }
      }
      if (!imageBlob) {
        new import_obsidian.Notice("No image found on clipboard.");
        return;
      }
      const nowForName = /* @__PURE__ */ new Date();
      const imgTimestamp = nowForName.toISOString().replace(/[:.]/g, "-");
      const imageName = `Clipboard Image ${imgTimestamp}.${imageBlob.type.split("/")[1] || "png"}`;
      const attachmentLocationSetting = this.app.vault.getConfig("attachmentFolderPath");
      let targetAttachmentFolder = "";
      if (attachmentLocationSetting === "/") {
        targetAttachmentFolder = "/";
      } else if (attachmentLocationSetting.startsWith("./")) {
        console.warn("Attachment folder for clipboard images is set to be relative to current note. Defaulting to vault root.");
        targetAttachmentFolder = attachmentLocationSetting.substring(2);
      } else {
        targetAttachmentFolder = attachmentLocationSetting;
      }
      targetAttachmentFolder = (0, import_obsidian.normalizePath)(targetAttachmentFolder);
      if (targetAttachmentFolder !== "/" && !await this.app.vault.adapter.exists(targetAttachmentFolder)) {
        try {
          await this.app.vault.createFolder(targetAttachmentFolder);
        } catch (folderErr) {
          new import_obsidian.Notice(`Failed to create attachment folder: ${targetAttachmentFolder} for clipboard image.`);
          return;
        }
      }
      let desiredAttachmentPath = (0, import_obsidian.normalizePath)(`${targetAttachmentFolder}/${imageName}`);
      let counter = 0;
      while (await this.app.vault.adapter.exists(desiredAttachmentPath)) {
        counter++;
        desiredAttachmentPath = (0, import_obsidian.normalizePath)(`${targetAttachmentFolder}/Clipboard Image ${imgTimestamp}-${counter}.${imageBlob.type.split("/")[1] || "png"}`);
      }
      const arrayBuffer = await imageBlob.arrayBuffer();
      const savedImageFile = await this.app.vault.createBinary(desiredAttachmentPath, arrayBuffer);
      new import_obsidian.Notice(`Image pasted and saved to: ${savedImageFile.path}`);
      const outputFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.screenshotNoteFolder);
      const nowForNote = /* @__PURE__ */ new Date();
      const noteDateString = nowForNote.toISOString().split("T")[0];
      const noteName = `${savedImageFile.basename}_${noteDateString}.md`;
      const notePath = (0, import_obsidian.normalizePath)(`${outputFolderRelPath}/${noteName}`);
      const frontmatter = `---
artifactGeneratedDate: ${(/* @__PURE__ */ new Date()).toISOString()}
---`;
      const embedLink = `![[${savedImageFile.path}]]`;
      const noteContent = `${frontmatter}

${embedLink}

`;
      const createdNote = await this.app.vault.create(notePath, noteContent);
      console.log(`Created note for clipboard image: ${notePath}`);
      let ocrText = null;
      let ocrError = null;
      const textExtractor = this.getTextExtractor();
      if (textExtractor && savedImageFile instanceof import_obsidian.TFile && textExtractor.canFileBeExtracted(savedImageFile.path)) {
        try {
          new import_obsidian.Notice(`Extracting text from pasted image ${savedImageFile.name}...`);
          console.log(`Starting OCR for pasted image ${savedImageFile.path} via Text Extractor...`);
          ocrText = await textExtractor.extractText(savedImageFile);
          console.log(`[RAW OCR - handlePasteFromClipboard for ${savedImageFile.path}] Raw result type: ${typeof ocrText}, Length: ${ocrText == null ? void 0 : ocrText.length}`);
          console.log(`[RAW OCR - handlePasteFromClipboard for ${savedImageFile.path}] First 500 chars:`, ocrText == null ? void 0 : ocrText.substring(0, 500));
          console.log(`Text Extractor successful for ${savedImageFile.path}. Length: ${ocrText ? ocrText.length : 0}`);
          if (ocrText && ocrText.trim().length > 0) {
            new import_obsidian.Notice(`Text extracted from pasted image.`);
          } else {
            new import_obsidian.Notice(`No text found or extracted from pasted image.`);
            ocrText = null;
          }
        } catch (err) {
          console.error(`Text Extractor failed for ${savedImageFile.path}:`, err);
          new import_obsidian.Notice(`Text extraction failed for pasted image.`);
          ocrError = err.message || "Unknown OCR error";
          ocrText = null;
        }
      } else {
        const reason = textExtractor ? `cannot process pasted image ${savedImageFile.name}` : "plugin not found";
        console.log(`Text Extractor not available or ${reason}.`);
        ocrError = `OCR not performed: Text Extractor ${reason}`;
      }
      this.screenshotIndex[savedImageFile.path] = {
        imagePath: savedImageFile.path,
        notePath,
        ocrText,
        ocrError,
        lastOcrAttemptDate: Date.now(),
        tags: ["clipboard-capture"]
      };
      await this.savePluginData();
      const activeLeaf = this.app.workspace.getLeaf(true);
      if (createdNote && activeLeaf) {
        await activeLeaf.openFile(createdNote);
      }
    } catch (err) {
      console.error("Failed to paste image from clipboard:", err);
      if (err.name === "NotAllowedError") {
        new import_obsidian.Notice("Clipboard permission denied. You might need to grant permission or click in Obsidian first.");
      } else if (err.message && err.message.includes("document is not focused")) {
        new import_obsidian.Notice("Cannot read clipboard: Obsidian window or an input field needs to be focused.");
      } else {
        new import_obsidian.Notice("Failed to paste image. See console.");
      }
    }
  }
  async mergeNotesImplementation(filesToMerge, newNoteName, outputFolderParentPath, shouldArchive) {
    if (filesToMerge.length < 2) {
      new import_obsidian.Notice("Select at least two notes.");
      return;
    }
    let mergedContent = "Merged from:\n";
    const sourceNotePaths = [];
    for (const file of filesToMerge) {
      mergedContent += `- ${file.path}
`;
      sourceNotePaths.push(file.path);
    }
    mergedContent += "\n***\n\n";
    for (let i = 0; i < filesToMerge.length; i++) {
      const file = filesToMerge[i];
      const content = await this.app.vault.cachedRead(file);
      const frontmatterRegex = /^---\s*\n[\s\S]*?^---\s*\n/m;
      const body = content.replace(frontmatterRegex, "");
      mergedContent += body;
      if (i < filesToMerge.length - 1) {
        mergedContent += "\n\n***\n\n";
      }
    }
    const newNotePath = (0, import_obsidian.normalizePath)(`${outputFolderParentPath}/${newNoteName}`);
    const newFrontmatter = `---
mergedDate: ${(/* @__PURE__ */ new Date()).toISOString()}
sourceNotes:
${sourceNotePaths.map((p) => `  - "${p}"`).join("\n")}
---

`;
    const finalContent = newFrontmatter + mergedContent;
    try {
      const createdNote = await this.app.vault.create(newNotePath, finalContent);
      new import_obsidian.Notice(`Successfully merged ${filesToMerge.length} notes into ${createdNote.path}`);
      if (shouldArchive) {
        const archiveFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.mergedNotesArchivePath);
        const archiveFolder = this.app.vault.getAbstractFileByPath(archiveFolderRelPath);
        if (!(archiveFolder instanceof import_obsidian.TFolder)) {
          try {
            await this.app.vault.createFolder(archiveFolderRelPath);
            console.log(`Created archive folder: ${archiveFolderRelPath}`);
          } catch (err) {
            new import_obsidian.Notice(`Failed to create archive folder: ${archiveFolderRelPath}. Originals not archived.`);
            console.error(`Failed to create archive folder ${archiveFolderRelPath}:`, err);
            const activeLeaf2 = this.app.workspace.getLeaf(true);
            if (createdNote && activeLeaf2)
              await activeLeaf2.openFile(createdNote);
            return;
          }
        }
        let archivedCount = 0;
        for (const originalNote of filesToMerge) {
          try {
            const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
            const archivedName = `${originalNote.basename}_${timestamp}.${originalNote.extension}`;
            const newArchivePath = (0, import_obsidian.normalizePath)(`${archiveFolderRelPath}/${archivedName}`);
            console.log(`Archiving ${originalNote.path} to ${newArchivePath}`);
            await this.app.vault.rename(originalNote, newArchivePath);
            archivedCount++;
          } catch (archiveErr) {
            console.error(`Failed to archive ${originalNote.path}:`, archiveErr);
            new import_obsidian.Notice(`Failed to archive ${originalNote.basename}. It remains in place.`);
          }
        }
        if (archivedCount > 0) {
          new import_obsidian.Notice(`Archived ${archivedCount} original note(s).`);
        }
      }
      const activeLeaf = this.app.workspace.getLeaf(true);
      if (createdNote && activeLeaf)
        await activeLeaf.openFile(createdNote);
    } catch (err) {
      console.error("Error creating merged note:", err);
      new import_obsidian.Notice("Error creating merged note. See console.");
    }
  }
  async handleCreateNoteForFile(file) {
    if (!(file instanceof import_obsidian.TFile)) {
      new import_obsidian.Notice("Selected item is not a valid file.");
      return;
    }
    const outputFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.screenshotNoteFolder);
    const outputFolder = this.app.vault.getAbstractFileByPath(outputFolderRelPath);
    if (!(outputFolder instanceof import_obsidian.TFolder)) {
      try {
        await this.app.vault.createFolder(outputFolderRelPath);
        console.log(`Created generic artifact note folder: ${outputFolderRelPath}`);
      } catch (err) {
        new import_obsidian.Notice(`Failed to create output folder: ${outputFolderRelPath}. Cannot create artifact note.`);
        console.error(`Failed to create output folder ${outputFolderRelPath}:`, err);
        return;
      }
    }
    const now = /* @__PURE__ */ new Date();
    const dateString = now.toISOString().split("T")[0];
    const noteName = `${file.basename}_${dateString}.md`;
    const notePath = (0, import_obsidian.normalizePath)(`${outputFolderRelPath}/${noteName}`);
    const embedLink = `![[${file.path}]]`;
    const noteContent = `${embedLink}

`;
    try {
      const createdNote = await this.app.vault.create(notePath, noteContent);
      new import_obsidian.Notice(`Created note for file: ${createdNote.path}`);
      const activeLeaf = this.app.workspace.getLeaf(true);
      if (createdNote && activeLeaf)
        await activeLeaf.openFile(createdNote);
      if (["png", "jpg", "jpeg", "gif", "bmp", "webp"].includes(file.extension.toLowerCase())) {
        console.log(`File ${file.path} is an image, attempting OCR and indexing.`);
        let ocrText = null;
        let ocrError = null;
        const textExtractor = this.getTextExtractor();
        if (textExtractor && textExtractor.canFileBeExtracted(file.path)) {
          try {
            new import_obsidian.Notice(`Extracting text from ${file.name}...`);
            ocrText = await textExtractor.extractText(file);
            console.log(`[RAW OCR - handleCreateNoteForFile for ${file.path}] Raw result type: ${typeof ocrText}, Length: ${ocrText == null ? void 0 : ocrText.length}`);
            console.log(`[RAW OCR - handleCreateNoteForFile for ${file.path}] First 500 chars:`, ocrText == null ? void 0 : ocrText.substring(0, 500));
            if (ocrText && ocrText.trim().length > 0) {
              new import_obsidian.Notice(`Text extracted from ${file.name}.`);
            } else {
              new import_obsidian.Notice(`No text found/extracted from ${file.name}.`);
              ocrText = null;
            }
          } catch (err) {
            console.error(`Text Extractor failed for ${file.path}:`, err);
            new import_obsidian.Notice(`Text extraction failed for ${file.name}.`);
            ocrError = err.message || "Unknown OCR error";
            ocrText = null;
          }
        } else {
          const reason = textExtractor ? `cannot process ${file.name}` : "plugin not found";
          ocrError = `OCR not performed: Text Extractor ${reason}`;
        }
        this.screenshotIndex[file.path] = {
          imagePath: file.path,
          notePath,
          ocrText,
          ocrError,
          lastOcrAttemptDate: Date.now(),
          tags: ["artifact-file", "image"]
        };
        await this.savePluginData();
      }
    } catch (err) {
      console.error(`Error creating note for file ${file.path}:`, err);
      new import_obsidian.Notice(`Error creating note for ${file.basename}. See console.`);
    }
  }
  async readLoomData() {
    const vaultRelativePath = (0, import_obsidian.normalizePath)(LOOM_DATA_PATH);
    console.log(`Attempting to read loom data from vault path: ${vaultRelativePath}`);
    try {
      const fileExists = await this.app.vault.adapter.exists(vaultRelativePath);
      if (!fileExists) {
        new import_obsidian.Notice(`Loom data file not found at: ${vaultRelativePath}`);
        console.error(`Loom data file not found at: ${vaultRelativePath}`);
        return null;
      }
      const jsonData = await this.app.vault.adapter.read(vaultRelativePath);
      if (!jsonData) {
        new import_obsidian.Notice("Loom data file is empty.");
        console.error("Loom data file is empty.");
        return null;
      }
      return JSON.parse(jsonData);
    } catch (error) {
      new import_obsidian.Notice("Error reading or parsing loom data file. See console for details.");
      console.error("Error reading/parsing loom data file:", error);
      return null;
    }
  }
  async buildLoomIndex(isManualRun = false) {
    var _a, _b;
    if (isManualRun)
      console.log("Manually building loom index...");
    else
      console.log("Building loom index (startup)...");
    const loomData = await this.readLoomData();
    if (!loomData || !loomData.state) {
      console.log("No loom data found or data is invalid. Loom index not built.");
      this.index = {};
      return;
    }
    const newIndex = {};
    try {
      for (const [documentPath, docState] of Object.entries(loomData.state)) {
        if (!docState || !docState.nodes)
          continue;
        for (const [nodeId, nodeData] of Object.entries(docState.nodes)) {
          if (!nodeData || typeof nodeData.text !== "string")
            continue;
          newIndex[nodeId] = {
            id: nodeId,
            parentId: (_a = nodeData.parentId) != null ? _a : null,
            text: nodeData.text,
            documentPath,
            bookmarked: (_b = nodeData.bookmarked) != null ? _b : false
          };
        }
      }
      this.index = newIndex;
      const message = `Loom Index built successfully with ${Object.keys(this.index).length} nodes.`;
      console.log(message);
      if (isManualRun)
        new import_obsidian.Notice(message);
    } catch (error) {
      new import_obsidian.Notice("Error building index from loom data. See console for details.");
      console.error("Error building loom index:", error);
      this.index = {};
    }
  }
  searchLoomIndex(query) {
    const lowerCaseQuery = query.toLowerCase();
    if (!lowerCaseQuery)
      return [];
    return Object.values(this.index).filter(
      (node) => node.text.toLowerCase().includes(lowerCaseQuery)
    );
  }
  searchScreenshots(query) {
    const lowerCaseQuery = query.toLowerCase();
    if (!lowerCaseQuery)
      return [];
    return Object.values(this.screenshotIndex).filter((info) => {
      return !!info.ocrText && info.ocrText.toLowerCase().includes(lowerCaseQuery);
    }).sort((a, b) => (b.lastOcrAttemptDate || 0) - (a.lastOcrAttemptDate || 0));
  }
  // --- Loomsidian Backup Logic ---
  async getLoomDataFileInfo() {
    const loomDataPath = (0, import_obsidian.normalizePath)(LOOM_DATA_PATH);
    try {
      const fileExists = await this.app.vault.adapter.exists(loomDataPath);
      if (fileExists) {
        const stats = await this.app.vault.adapter.stat(loomDataPath);
        if (stats && stats.type === "file") {
          console.log(`[getLoomDataFileInfo] Found: ${loomDataPath}, Size: ${stats.size}, mtime: ${stats.mtime}`);
          return { path: loomDataPath, size: stats.size, exists: true, mtime: stats.mtime };
        }
      }
      console.warn(`[getLoomDataFileInfo] Loomsidian data.json not found or not a file at: ${loomDataPath}`);
      return { path: loomDataPath, size: 0, exists: false, mtime: 0 };
    } catch (err) {
      console.error(`[getLoomDataFileInfo] Error accessing Loomsidian data.json at ${loomDataPath}:`, err);
      return null;
    }
  }
  async performLoomBackup(sourcePath, currentSize) {
    if (!this.settings.enableLoomBackup)
      return;
    const backupFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.loomBackupFolderPath);
    try {
      const backupFolder = this.app.vault.getAbstractFileByPath(backupFolderRelPath);
      if (!(backupFolder instanceof import_obsidian.TFolder)) {
        await this.app.vault.createFolder(backupFolderRelPath);
        console.log(`Created Loomsidian backup folder: ${backupFolderRelPath}`);
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const backupFileName = `data_${timestamp}.json`;
      const backupDestPath = (0, import_obsidian.normalizePath)(`${backupFolderRelPath}/${backupFileName}`);
      await this.app.vault.adapter.copy(sourcePath, backupDestPath);
      new import_obsidian.Notice(`Loomsidian data backed up to ${backupDestPath}`, 5e3);
      console.log(`Loomsidian data backed up: ${sourcePath} -> ${backupDestPath}`);
      this.lastLoomDataBackupSize = currentSize;
      await this.savePluginData();
      const fileList = await this.app.vault.adapter.list(backupFolderRelPath);
      const backupFiles = fileList.files.filter((p) => p.endsWith(".json") && p.startsWith((0, import_obsidian.normalizePath)(backupFolderRelPath + "/data_"))).map((filePath) => ({ path: filePath, name: filePath.split("/").pop() || "" })).sort((a, b) => b.name.localeCompare(a.name));
      if (backupFiles.length > this.settings.maxLoomBackups) {
        const toDelete = backupFiles.slice(this.settings.maxLoomBackups);
        let prunedCount = 0;
        for (const oldBackup of toDelete) {
          try {
            await this.app.vault.adapter.remove(oldBackup.path);
            console.log(`Pruned old Loom backup: ${oldBackup.path}`);
            prunedCount++;
          } catch (e) {
            console.error(`Failed to prune old Loom backup ${oldBackup.path}:`, e);
          }
        }
        if (prunedCount > 0) {
          new import_obsidian.Notice(`Pruned ${prunedCount} old Loom backup(s).`, 3e3);
        }
      }
    } catch (err) {
      new import_obsidian.Notice("Failed to create Loomsidian backup. Check console.", 0);
      console.error("Loomsidian backup failed:", err);
    }
  }
  async triggerLoomBackupCheck(isManual = false) {
    if (!this.settings.enableLoomBackup && !isManual) {
      console.log("Loom backup disabled, check skipped.");
      return;
    }
    const loomDataFileInfo = await this.getLoomDataFileInfo();
    if (!loomDataFileInfo || !loomDataFileInfo.exists) {
      if (isManual && (!loomDataFileInfo || !loomDataFileInfo.exists))
        new import_obsidian.Notice("Loomsidian data.json not found. Cannot backup.");
      if (this.lastLoomDataBackupSize !== 0) {
        console.log("Loomsidian data.json not found or inaccessible. Resetting last backup size to 0.");
        this.lastLoomDataBackupSize = 0;
        await this.savePluginData();
      }
      return;
    }
    const currentSize = loomDataFileInfo.size;
    if (currentSize === 0) {
      if (this.lastLoomDataBackupSize !== 0) {
        console.log("Loomsidian data.json is currently empty. Resetting last backup size to 0.");
        this.lastLoomDataBackupSize = 0;
        await this.savePluginData();
      }
      if (isManual)
        new import_obsidian.Notice("Loomsidian data.json is empty. Manual backup skipped.");
      return;
    }
    if (isManual) {
      new import_obsidian.Notice("Manual Loomsidian backup initiated...");
      await this.performLoomBackup(loomDataFileInfo.path, currentSize);
      return;
    }
    if (this.lastLoomDataBackupSize === 0 || currentSize > this.lastLoomDataBackupSize + this.settings.loomBackupGrowthThresholdKB * 1024) {
      const reason = this.lastLoomDataBackupSize === 0 ? "initial content detected" : "growth threshold met";
      console.log(`Loomsidian data.json: ${reason}. Performing backup. Current size: ${currentSize}B, Last: ${this.lastLoomDataBackupSize}B, Threshold: ${this.settings.loomBackupGrowthThresholdKB}KB`);
      await this.performLoomBackup(loomDataFileInfo.path, currentSize);
    } else {
      console.log(`Loom data size (${currentSize}B) has not met growth threshold (${this.settings.loomBackupGrowthThresholdKB}KB) over last backup size (${this.lastLoomDataBackupSize}B).`);
    }
  }
  rescheduleDailyLoomBackupCheck() {
    if (this.dailyLoomBackupIntervalId !== null) {
      window.clearInterval(this.dailyLoomBackupIntervalId);
      this.dailyLoomBackupIntervalId = null;
      console.log("Cleared existing daily Loom backup check interval.");
    }
    if (!this.settings.enableLoomBackup || !this.settings.enableDailyLoomBackupCheck) {
      console.log("Daily Loom backup check is disabled.");
      return;
    }
    const now = /* @__PURE__ */ new Date();
    const checkTimeParts = this.settings.dailyLoomBackupCheckTime.split(":");
    const checkHour = parseInt(checkTimeParts[0]);
    const checkMinute = parseInt(checkTimeParts[1]);
    if (isNaN(checkHour) || isNaN(checkMinute)) {
      console.error("Invalid dailyLoomBackupCheckTime format in settings.");
      return;
    }
    let nextCheck = /* @__PURE__ */ new Date();
    nextCheck.setHours(checkHour, checkMinute, 0, 0);
    if (nextCheck <= now) {
      nextCheck.setDate(nextCheck.getDate() + 1);
    }
    const delayUntilNextCheck = nextCheck.getTime() - now.getTime();
    console.log(`Scheduling next daily Loom backup check for: ${nextCheck.toLocaleString()} (in ${Math.round(delayUntilNextCheck / 6e4)} minutes)`);
    const timeoutId = window.setTimeout(() => {
      console.log("Executing scheduled daily Loom backup check.");
      this.triggerLoomBackupCheck();
      if (this.settings.enableLoomBackup && this.settings.enableDailyLoomBackupCheck) {
        this.dailyLoomBackupIntervalId = window.setInterval(() => {
          console.log("Executing daily Loom backup check (interval).");
          this.triggerLoomBackupCheck();
        }, 24 * 60 * 60 * 1e3);
        console.log("Daily Loom backup check interval started.");
      }
    }, delayUntilNextCheck);
  }
  async exportFullLoomForDocument(docFile) {
    console.log(`Attempting to export full Loom for document: ${docFile.path}`);
    new import_obsidian.Notice(`Exporting Loom data for ${docFile.basename}...`, 3e3);
    const loomData = await this.readLoomData();
    if (!loomData || !loomData.state || !loomData.state[docFile.path]) {
      new import_obsidian.Notice(`No Loomsidian data found for ${docFile.path}. Cannot export.`);
      console.warn(`No Loomsidian data found for ${docFile.path}.`);
      return;
    }
    const noteState = loomData.state[docFile.path];
    if (!noteState.nodes || Object.keys(noteState.nodes).length === 0) {
      new import_obsidian.Notice(`No nodes found in Loomsidian data for ${docFile.path}. Cannot export.`);
      console.warn(`No nodes found in Loomsidian data for ${docFile.path}.`);
      return;
    }
    const exportFolderRelPath = (0, import_obsidian.normalizePath)(this.settings.loomExportsFolderPath);
    try {
      const exportFolder = this.app.vault.getAbstractFileByPath(exportFolderRelPath);
      if (!(exportFolder instanceof import_obsidian.TFolder)) {
        await this.app.vault.createFolder(exportFolderRelPath);
        console.log(`Created Loom export folder: ${exportFolderRelPath}`);
      }
    } catch (err) {
      new import_obsidian.Notice(`Failed to create Loom export folder: ${exportFolderRelPath}. Cannot export.`);
      console.error(`Failed to create Loom export folder ${exportFolderRelPath}:`, err);
      return;
    }
    const baseName = docFile.basename;
    const jsonExportName = `${baseName}.loomartifact.json`;
    const mdExportName = `${baseName}.loomartifact.md`;
    const jsonExportPath = (0, import_obsidian.normalizePath)(`${exportFolderRelPath}/${jsonExportName}`);
    const mdExportPath = (0, import_obsidian.normalizePath)(`${exportFolderRelPath}/${mdExportName}`);
    const exportJsonData = {
      current: noteState.current,
      // The current node ID from the original loom for this doc
      nodes: noteState.nodes
      // The complete set of nodes for this document's loom
    };
    try {
      await this.app.vault.create(jsonExportPath, JSON.stringify(exportJsonData, null, 2));
      console.log(`Exported Loom JSON data to: ${jsonExportPath}`);
    } catch (err) {
      new import_obsidian.Notice(`Failed to export Loom JSON data to ${jsonExportPath}. See console.`);
      console.error(`Failed to export Loom JSON data to ${jsonExportPath}:`, err);
      return;
    }
    let currentPathText = "(Could not reconstruct current path for exported loom)";
    if (exportJsonData.current && exportJsonData.nodes) {
      let text = "";
      let currentId = exportJsonData.current;
      const nodesMap = exportJsonData.nodes;
      while (currentId) {
        const node = nodesMap[currentId];
        if (node && typeof node.text === "string") {
          text = node.text + text;
          currentId = node.parentId;
        } else {
          console.warn(`Node ${currentId} not found or text missing during MD export reconstruction.`);
          currentId = null;
        }
      }
      currentPathText = text;
    }
    const mdFrontmatter = `---
artifactType: loom-export
loomDataFile: "./${jsonExportName}"
exportedDate: ${(/* @__PURE__ */ new Date()).toISOString()}
originalDocPath: "${docFile.path}"
originalCurrentNodeId: "${noteState.current || ""}"
---

`;
    const mdContent = mdFrontmatter + currentPathText;
    try {
      await this.app.vault.create(mdExportPath, mdContent);
      console.log(`Exported Loom Markdown to: ${mdExportPath}`);
      new import_obsidian.Notice(`Successfully exported Loom for ${docFile.basename} to ${exportFolderRelPath}.`, 0);
    } catch (err) {
      new import_obsidian.Notice(`Failed to export Loom Markdown to ${mdExportPath}. JSON data was saved. See console.`);
      console.error(`Failed to export Loom Markdown to ${mdExportPath}:`, err);
    }
  }
};
